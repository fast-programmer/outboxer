#!/usr/bin/env ruby

require "bundler/setup"
require "outboxer"
require "aws-sdk-sqs"

cli_options = Outboxer::Publisher.parse_cli_options(ARGV)
environment = cli_options.delete(:environment) ||
              ENV["APP_ENV"] || ENV["RAILS_ENV"] || "development"
options = Outboxer::Publisher::PUBLISH_MESSAGE_DEFAULTS.merge(cli_options)

database_config = Outboxer::Database.config(
  environment: environment,
  pool: Outboxer::Publisher.pool(concurrency: options[:concurrency]))

Outboxer::Database.connect(config: database_config)

sqs_client = Aws::SQS::Client.new(region: ENV.fetch("AWS_REGION", "us-east-1"))
sqs_queue_url = ENV.fetch("SQS_QUEUE_URL")

begin
  Outboxer::Publisher.publish_messages(batch_size: 10) do |publisher, messages|
    begin
      response = sqs_client.send_message_batch(
        queue_url: sqs_queue_url,
        entries: messages.map do |message|
          {
            id: message[:id].to_s,
            message_body: {
              messageable_type: message[:messageable_type],
              messageable_id: message[:messageable_id]
            }.to_json
          }
        end)
    rescue => error
      Outboxer::Publisher.update_messages(
        id: publisher[:id],
        failed_messages: messages.map do |message|
          {
            id: message[:id],
            exception: {
              class_name: error.class.name,
              message_text: error.message,
              backtrace: error.backtrace
            }
          }
        end)
    else
      Outboxer::Publisher.update_messages(
        id: publisher[:id],
        published_message_ids: response.successful.map { |entry| entry.id.to_i },
        failed_messages: response.failed.map do |entry|
          {
            id: entry.id.to_i,
            exception: {
              class_name: "Aws::SQS::Types::BatchResultErrorEntry",
              message_text: "code=#{entry.code}, message=#{entry.message}"
            }
          }
        end,
        time: Time)
    end
  end
ensure
  Outboxer::Database.disconnect
end
