#!/usr/bin/env ruby

require "sidekiq"

cli_options = Outboxer::Publisher.parse_cli_options(ARGV)
environment = cli_options.delete(:environment) ||
              ENV["APP_ENV"] || ENV["RAILS_ENV"] || "development"
options = Outboxer::Publisher::PUBLISH_MESSAGES_DEFAULTS.merge(cli_options)

database_config = Outboxer::Database.config(
  environment: environment,
  pool: Outboxer::Publisher.pool(concurrency: options[:concurrency]))

Outboxer::Database.connect(config: database_config)

Sidekiq.configure_client do |config|
  config.redis = { url: ENV.fetch("REDIS_URL", "redis://localhost:6379/0"), size: 5 }
end

Outboxer::Publisher.publish_messages(batch_size: 1_000, concurrency: 10) do |publisher, messages|
  begin
    job_ids = Sidekiq::Client.push_bulk(
      messages.map do |message|
        {
          "class" => message[:messageable_type].to_s.sub(/Event$/, "Job"),
          "args" => [message[:messageable_id]]
        }
      end)
  rescue => error
    Outboxer::Publisher.update_messages(
      id: publisher[:id],
      failed_messages: messages.map do |message|
        {
          id: message[:id],
          exception: {
            class_name: error.class.name,
            message_text: error.message,
            backtrace: error.backtrace.join("\n")
          }
        }
      end)
  else
    published_messages, failed_messages = messages.zip(job_ids).partition { |_, job_id| job_id }

    Outboxer::Publisher.update_messages(
      id: publisher[:id],
      published_message_ids: published_messages.map { |message, _| message[:id] },
      failed_messages: failed_messages.map do |message, _|
        {
          id: message[:id],
          exception: {
            message_text: "Job not enqueued (blocked by client middleware)"
          }
        }
      end)
  end
end
