#!/usr/bin/env ruby

require "bundler/setup"
require "outboxer"
require "sidekiq"

cli_options = Outboxer::Publisher.parse_cli_options(ARGV)
environment = cli_options.delete(:environment) || ENV["APP_ENV"] || ENV["RAILS_ENV"] || "development"
options = Outboxer::Publisher::PUBLISH_MESSAGES_DEFAULTS.merge(cli_options)
logger = Outboxer::Logger.new($stdout, level: options[:log_level])

database_config = Outboxer::Database.config(
  environment: environment, pool: Outboxer::Publisher.pool(concurrency: options[:concurrency]))

Outboxer::Database.connect(config: database_config, logger: logger)

begin
  Outboxer::Publisher.publish_messages(batch_size: 1_000) do |publisher, messages|
    begin
      job_ids = Sidekiq::Client.push_bulk(
        messages.map do |message|
          {
            "class" => message[:messageable_type].sub(/Event$/, "Job"),
            "args" => [message[:messageable_id]]
          }
        end)
    rescue => error
      logger.error(
        "Sidekiq::Client#push_bulk failed for publisher_id=#{publisher[:id]} " \
        "message_ids=#{messages.map { |message| message[:id] }.join(",")}\n" \
        "#{error.class}: #{error.message}\n" \
        "#{error.backtrace.join("\n")}")

      Outboxer::Publisher.update_messages_by_ids(
        publisher_id: publisher[:id],
        publisher_name: publisher[:name],
        failed_message_ids: messages.map { |message| message[:id] })
    else
      Outboxer::Publisher.update_messages_by_ids(
        publisher_id: publisher[:id],
        publisher_name: publisher[:name],
        published_message_ids: messages
          .zip(job_ids)
          .select { |_, job_id| job_id }
          .map { |message, _| message[:id] },
        failed_message_ids: messages
          .zip(job_ids)
          .reject { |_, job_id| job_id }
          .map { |message, _| message[:id] })
    end
  end
ensure
  Outboxer::Database.disconnect(logger: logger)
end
