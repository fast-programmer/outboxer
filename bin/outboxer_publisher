#!/usr/bin/env ruby

require 'bundler/setup'
require 'sidekiq'
require 'outboxer'

require_relative '../app/jobs/event_created_job'

options = {
  environment: ENV.fetch('OUTBOXER_ENV', 'development'),
  batch_size: ENV.fetch('OUTBOXER_BATCH_SIZE', 100),
  poll_interval: ENV.fetch('OUTBOXER_POLL_INTERVAL', 5),
  tick_interval: ENV.fetch('OUTBOXER_TICK_INTERVAL', 1),
  log_level: ENV.fetch('OUTBOXER_LOG_LEVEL', 'info').downcase,
  sidekiq_redis_url: ENV.fetch('SIDEKIQ_REDIS_URL', 'redis://localhost:6379/0'),
}

Sidekiq.configure_client do |config|
  config.redis = { url: options[:sidekiq_redis_url], size: 1 }
end

logger = Outboxer::Logger.new $stdout, level: Logger.const_get(options[:log_level].upcase)
logger.info "Outboxer v#{Outboxer::VERSION} starting in ruby #{RUBY_VERSION} " \
            "(#{RUBY_RELEASE_DATE} revision #{RUBY_REVISION[0, 10]}) [#{RUBY_PLATFORM}]"

db_config = Outboxer::Database.config(environment: options[:environment], pool: 1)

Outboxer::Database.connect(config: db_config, logger: logger)

['INT', 'TERM'].each do |signal|
  Signal.trap(signal) do
    Outboxer::Publisher.stop
  end
end

Outboxer::Publisher.publish(
  batch_size: options[:batch_size],
  poll_interval: options[:poll_interval],
  tick_interval: options[:tick_interval],
  logger: logger
) do |message|
  case message[:messageable_type]
  when 'Event'
    EventCreatedJob.perform_async({ 'id' => message[:messageable_id] })
  end
end

Outboxer::Database.disconnect(logger: logger)

# bin/outboxer_publisher
